module.exports.BroadCast = function(prop){
    var self = this;
    this.property = prop;
    this.channels = new Array();

    this.createChannel = function (id, maxmsg){
        if(self.channels.hasOwnProperty(id))return null;
        var channel = new newChannel(maxmsg, self.property);
        self.channels[id] = channel;
        return channel;
    }

    this.getChannel = function(id){
        if(!self.channels.hasOwnProperty(id))return null;
        return self.channels[id];
    }

    this.loadChannel = function(id, maxmsg){
        if(self.channels.hasOwnProperty(id))return self.getChannel(id);
        else return self.createChannel(id, maxmsg);
    }
    return this;
}

function newChannel (maxmsg){
    var self = this;
    var callbacks = [];
    var messages = [];
    var MaxMsg = maxmsg?maxmsg:100;

    this.postMsg = function(user, type, msg){
        var m = {
            user: user,
            type: type,
            msg: msg,
            timestamp: (new Date()).getTime()
        };
        messages.push(m);

        while(callbacks.length > 0){
            callbacks.shift().callback([m]);
        }

        while(messages.length > MaxMsg){
            messages.shift();
        }
    };

    this.readMsg = function(since, callback){
        var msgs = [];
        for(var i=0; i < messages.length; ++i){
            if(messages[i].timestamp > since)
                msgs.push(messages[i]);
        }

        if(msgs.length != 0){
            callback(msgs);
        }else{
            callbacks.push({timestamp:new Date(), callback: callback});
        }
    }
    //Clean old callback (idle time 30 sec)
    setInterval(function(){
        var now = new Date();
        while(callbacks.length > 0 && now - callbacks[0].timestamp > 30*1000){
            callbacks.shift().callback([]);
        }
    }, 3000);
    console.log('New Channel MaxMsg ' +MaxMsg);
}
