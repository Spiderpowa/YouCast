module.exports.BroadCast = function(prop){
    var self = this;
    var expireTime = 180; // 3 minutes
    var property = prop;
    this.channels = new Array();

    this.createChannel = function (id, maxmsg){
        if(self.channels.hasOwnProperty(id))return null;
        var channel = new Channel(maxmsg, property);
        self.channels[id] = channel;
        return channel;
    }

    this.getChannel = function(id){
        if(!self.channels.hasOwnProperty(id))return null;
        return self.channels[id];
    }

    this.loadChannel = function(id, maxmsg){
        if(self.channels.hasOwnProperty(id))return self.getChannel(id);
        else return self.createChannel(id, maxmsg);
    }

    this.expire = function(){
        var now = time();
        for(var key in self.channels){
            if(now - self.channels[key].getTime() > expireTime){
                console.log('['+property.title+'] expire channel ' + key);
                delete self.channels[key];
            }
        }
    }

    //Check Expire every minute
    setInterval(this.expire, 60000);

    return this;
}

function Channel (maxmsg, prop){
    var self = this;
    var callbacks = [];
    var messages = [];
    var MaxMsg = maxmsg?maxmsg:100;
    var timeStamp;
    var property = prop;

    this.postMsg = function(user, type, msg){
        var m = {
            user: user,
            type: type,
            msg: msg,
            timestamp: (new Date()).getTime()
        };
        messages.push(m);

        //A new message, deal with previous request
        while(callbacks.length > 0){
            callbacks.shift().callback([m]);
        }

        while(messages.length > MaxMsg){
            messages.shift();
        }
    };

    this.readMsg = function(since, callback){
        var msgs = [];
        for(var i=0; i < messages.length; ++i){
            if(messages[i].timestamp > since)
                msgs.push(messages[i]);
        }

        if(msgs.length != 0){
            callback(msgs);
        }else{
            //No message, put request into callback array
            callbacks.push({timestamp:new Date(), callback: callback});
        }
    };

    this.touch = function(){
        timeStamp = time();
    };

    this.getTime = function(){
        return timeStamp;
    };

    this.touch();
    //Clean old callback (idle time 30 sec)
    setInterval(function(){
        var now = new Date();
        while(callbacks.length > 0 && now - callbacks[0].timestamp > 30*1000){
            callbacks.shift().callback([]);
        }
    }, 3000);
    console.log('['+property.title+'] New Channel MaxMsg ' +MaxMsg);
}

function time(){
    return Math.round((new Date()).getTime() / 1000);
}
